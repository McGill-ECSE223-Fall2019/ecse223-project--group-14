namespace ca.mcgill.ecse223.quoridor.controller;

use QuoridorGame.ump;

class PawnBehavior {

    0..1 -> 0..1 Game currentGame;
    0..1 -> 0..1 Player player;
	
	MoveDirection side;
	int targetRow;
	int targetCol;
	
    pawnSM {
    	Placed{
    		initiateMove(int targetRow, int targetCol, MoveDirection side) [!wallBlocksMove(side)]/{
    			// Save target move variables for future checks
    			this.targetRow = targetRow;
    			this.targetCol = targetCol;
    			this.side = side;
    		} -> Moving;
    		initiateMove(int targetRow, int targetCol, MoveDirection side) [wallBlocksMove(side)] -> {
    			// If wall directly in front of player, can't step or jump
    			illegalMove();
    		} -> Placed;
    	}
    	Moving{
    		entry [!(isStepMove() && !opponentBlocksMove()) 
    			&& !(isJumpMove() && opponentBlocksMove())]/ {
    			illegalMove();
    		} -> Placed;
    		entry [isStepMove() && !opponentBlocksMove()] -> Stepping;
    		entry [isJumpMove() && opponentBlocksMove()] -> Jumping;
    	}
		Stepping{
			entry / {
				// Do the actual step
			} -> Placed;
		}
		Jumping{
			entry [wallBlockingJump()] -> JumpingDiagonal;
			entry [!wallBlockingJump()] -> JumpingStraight;
		}
	    JumpingStraight{
	    	entry / {
				// Do the actual jump straight
			} -> Placed;
		}
		JumpingDiagonal{
			entry / {
				// Do the actual jump diagonally
			} -> Placed;
		}
		
	}
    // Returns the current row number of the pawn
    int getCurrentPawnRow() { 
    	GamePosition pos = QuoridorApplication.getQuoridor().getCurrentPosition();
    	Player currentPlayer = pos.getPlayerToMove();
    	if (currentPlayer.hasGameAsWhite())(
	    	return pos.getWhitePosition().getTile().getRow();
	    else{
	    	return pos.getBlackPosition().getTile().getRow();
	    }
    }
    
    // Returns the current column number of the pawn
    int getCurrentPawnColumn() {
    	GamePosition pos = QuoridorApplication.getQuoridor().getCurrentPosition();
    	Player currentPlayer = pos.getPlayerToMove();
    	if (currentPlayer.hasGameAsWhite())(
	    	return pos.getWhitePosition().getTile().getCol();
	    else{
	    	return pos.getBlackPosition().getTile().getCol();
	    }
    }
    
    // Returns the current row number of the opponent's pawn
    int getOpponentPawnRow(){
    	// TODO
    }
    
    // Returns the current column number of the opponent's pawn
    int getOpponentPawnColumn(){
    	// TODO
    }
    
    // Returns if it is legal to step in the given direction
    boolean wallBlocksMove() {
    	int row = getCurrentPawnRow();
		int col = getCurrentPawnCol();
    	
    	// Check if no wall infront of player in direction (side)
    	if(this.side.equals(MoveDirection.North) && (wallExistsAt(row,col,true) || wallExistsAt(row,col+1,true))) return true;
    	else if(this.side.equals(MoveDirection.South) && (wallExistsAt(row+1,col,true) || wallExistsAt(row+1,col+1,true))) return true;
    	else if(this.side.equals(MoveDirection.West) && (wallExistsAt(row,col,false) || wallExistsAt(row+1,col,false))) return true;
    	else if(this.side.equals(MoveDirection.East) && (wallExistsAt(row,col+1,false) || wallExistsAt(row+1,col+1,false))) return true;
    	
    	return false;
    }
    
    // Returns if a wall exists at a certain tile in a certain orientation
    boolean wallExistsAt(int row, int col, boolean isHorizontal){
    	GamePosition pos = QuoridorApplication.getQuoridor().getCurrentPosition();
    	
    	if(isHorizontal) Direction wallDir = Direction.Horizontal;
    	else Direction wallDir = Direction.Vertical;
    	
    	for(Wall wall : pos.getWhiteWallsOnBoard())
    		if (wall.getMove().getDirection().equals(wallDir) && wall.getRow() == row && wall.getCol() == col) return true;
    	for(Wall wall : pos.getBlackWallsOnBoard())
    		if (wall.getMove().getDirection().equals(wallDir) && wall.getRow() == row && wall.getCol() == col) return true;
	    			
	    return false;
    }
    
    boolean isStepMove(){
   		// TODO Basically check if targetRow & Col are 1 step away from current pawn position
   	}
   	
   	boolean isJumpMove(){
   		// TODO Basically check either if targetRow & Col are 2 steps away, or if side is diagonal direction
   	}
    
    // Returns if it is legal to jump in the given direction
    boolean opponentBlocksMove() {
    	int row = getCurrentPawnRow();
		int col = getCurrentPawnColumn();
		
		int oprow = getOpponentPawnRow();
		int opcol = getOpponentPawnColumn();
		
		// Check if the opponent pawn is adjacent to pawn in given dir
		if(this.side.equals(MoveDirection.North) && oprow == row-1 && opcol == col) return true;
    	else if(this.side.equals(MoveDirection.South) && oprow == row+1 && opcol == col) return true;
    	else if(this.side.equals(MoveDirection.West) && oprow == row && opcol == col-1) return true;
    	else if(this.side.equals(MoveDirection.East) && oprow == row && opcol == col+1) return true;
		
    	return false;
    }
    
	
    // Action to be called when an illegal move is attempted
    void illegalMove() {
    	// Tell UI no
    	
    }
    
    // Enumeration for the possible moving directions
    // (directions are from the viewpoint of white player)
    enum MoveDirection { East, South, West, North, SouthEast, SouthWest, NorthEast, NorthWest}
}
