namespace ca.mcgill.ecse223.quoridor.controller;

use QuoridorGame.ump;

class PawnBehavior {
	depend java.util.List;
    0..1 -> 0..1 Game currentGame;
    0..1 -> 0..1 Player player;
	
	boolean isValid;
	int row;
	int col;
	String side;
	String status;
		
    pawnSM {
    	Placed{
    		initiateDiagonalJump(int row, int col, String side) -> /{
    			initPawn(row,col,side);
    		}  JumpingDiagonal;
    		initiateStep(int row, int col, String side) -> /{
    			initPawn(row,col,side);
    		}  Stepping;
    		initiateStraightJump(int row, int col, String side) -> /{
    			initPawn(row,col,side);
    		}  JumpingStraight;
    	}
		Stepping{
			entry / {isValid = isLegalStep();}
			dropPawn(int row, int col) -> /{
    			updateModel(row,col);				//TODO all of these should have isValid as a barrier
    			legalMove();
    		}  Placed;
    		cancel() -> /{
    			illegalMove();
    		}Placed;
			
		}
	    JumpingStraight{
	    	entry / {isValid = isLegalJump();}
	    	dropPawn(int row, int col) -> /{
    			updateModel(row,col);
    			legalMove();
    		}  Placed;
    		cancel() -> /{
    			illegalMove();
    		}Placed;
		}
		JumpingDiagonal{
			entry / {isValid = isLegalJumpDiag();}
			dropPawn(int row, int col) -> /{
    			updateModel(row,col);
    			legalMove();
    		}  Placed;
    		cancel() -> /{
    			illegalMove();
    		}Placed;
		}
	}
	
	//TODO account for diagonal jumps via wall
	
	void updateModel(int row, int col){
		status="success";
		//TODO either create new game position and set current or update current one
	}
    // Returns the current row number of the pawn
    int getCurrentPawnRow() { 
    	GamePosition pos = currentGame.getCurrentPosition();
    	if (player.hasGameAsWhite()){
	    	return pos.getWhitePosition().getTile().getRow();
	    }
	    else{
	    	return pos.getBlackPosition().getTile().getRow();
	    }
    }
    
    
    
    // Returns the current column number of the pawn
    int getCurrentPawnColumn() {
    	GamePosition pos=currentGame.getCurrentPosition();
    	if (player.hasGameAsWhite()){
	    	return pos.getWhitePosition().getTile().getColumn();
	    }
	    else{
	    	return pos.getBlackPosition().getTile().getColumn();
	    }
    }
    
    // Returns the current row number of the pawn
    int getOpponentPawnRow() { 
    	GamePosition pos=currentGame.getCurrentPosition();
    	if (player.hasGameAsWhite()){
	    	return pos.getBlackPosition().getTile().getRow();
	    }
	    else{
	    	return pos.getWhitePosition().getTile().getRow();
	    }
    }
    
    
    
    // Returns the current column number of the pawn
    int getOpponentPawnColumn() {
    	GamePosition pos=currentGame.getCurrentPosition();
    	if (player.hasGameAsWhite()){
	    	return pos.getBlackPosition().getTile().getColumn();
	    }
	    else{
	    	return pos.getWhitePosition().getTile().getColumn();
	    }
    }
    
    // Returns if it is legal to step in the given direction
    boolean isLegalStep() { 
    	int opRow = getOpponentPawnRow();
    	int opCol = getOpponentPawnColumn();
    	
    	int curRow = getCurrentPawnRow();
		int curCol = getCurrentPawnColumn();
		
		String opSide = isOpponentAdjacent(curRow,curCol,opRow,opCol);
    	
    	Boolean walla= isWallBlocking(curRow,curCol,opSide,true);  //if adjacent wall
    	if (walla){
    		return false;
    	}
    	
    	return true; 
    }
    
    // Returns if it is legal to jump in the given direction
    boolean isLegalJump() { 
    	int opRow = getOpponentPawnRow();
    	int opCol = getOpponentPawnColumn();
    	
    	int curRow = getCurrentPawnRow();
		int curCol = getCurrentPawnColumn();
		
		String opSide = isOpponentAdjacent(curRow,curCol,opRow,opCol);
    	Boolean wallb= isWallBlocking(opRow,opCol,opSide,false); 	//wall adjacent to opponent
    	Boolean walla= isWallBlocking(curRow,curCol,opSide,true);  //if adjacent wall
		
		if ((!wallb)||(walla)){
    		return false;
    	}
		else if(this.side.compareTo(opSide)==0){
			return true;
		} 
		
		else {
			return false;
		}
    }
    
    boolean isLegalJumpDiag() { 
    	int opRow = getOpponentPawnRow();
    	int opCol = getOpponentPawnColumn();
    	
    	int curRow = getCurrentPawnRow();
    	int curCol = getCurrentPawnColumn();
    	
    	String opSide = isOpponentAdjacent(curRow,curCol,opRow,opCol);
    	Boolean wallb= isWallBlocking(curRow,curRow,opSide,false); 
    	Boolean walla= isWallBlocking(curRow,curCol,opSide,true);  //if adjacent wall
    	Boolean border= isBorderBlocking(opRow,opCol,opSide);
    	if (((!border)&&(!wallb))||(walla)){
    		return false;
    	}
		else if(this.side.equals("upleft")){
			if((opSide.equals("up")) || opSide.equals("left")){
				return true;
			}
		} 
		
		else if(this.side.equals("upright")){
			if((opSide.equals("up")) || opSide.equals("right")){
				return true;
			}
		} 
		else if(this.side.equals("downleft")){
			if((opSide.equals("down")) || opSide.equals("left")){
				return true;
			}
		} 
		else if(this.side.equals("downright")){
			if((opSide.equals("down")) || opSide.equals("right")){
				return true;
			}
		}
		
    	return false;
    }
    
	void initPawn(int row,int col,String side){
		this.row = row;
		this.col = col;
		this.side = side;
	}
	
	boolean isWallBlocking(int curRow, int curCol,String side,boolean isStep){
    	int distance;
    	if(isStep){
    		distance=1;
    	}
    	else {
    		distance = 2;
    	}
    	GamePosition curr= currentGame.getCurrentPosition();
		
		List<Wall> wWall = curr.getWhiteWallsOnBoard();
		List<Wall> bWall = curr.getBlackWallsOnBoard();
		
    	if(this.side.equals("up")){
			for(Wall w: wWall){
				if (w.getMove().getWallDirection().toString().compareTo("Horizontal")==0){
					if (w.getMove().getTargetTile().getRow()==curRow-distance){
						if ((w.getMove().getTargetTile().getColumn()==curCol)||(w.getMove().getTargetTile().getColumn()==curCol-1)){
							return true;
						}
					}
				}
			}
			for(Wall w: bWall){
				if (w.getMove().getWallDirection().toString().compareTo("Horizontal")==0){
					if (w.getMove().getTargetTile().getRow()==curRow-distance){
						if ((w.getMove().getTargetTile().getColumn()==curCol)||(w.getMove().getTargetTile().getColumn()==curCol-1)){
							return true;
						}
					}
				}
			}
		}
		else if(this.side.equals("right")){
			for(Wall w: wWall){
				if (w.getMove().getWallDirection().toString().compareTo("Vertical")==0){
					if (w.getMove().getTargetTile().getColumn()==curCol-1+distance){
						if ((w.getMove().getTargetTile().getRow()==curRow)||(w.getMove().getTargetTile().getRow()==curRow-1)){
							return true;
						}
					}
				}
			}
			for(Wall w: bWall){
				if (w.getMove().getWallDirection().toString().compareTo("Vertical")==0){
					if (w.getMove().getTargetTile().getColumn()==curCol-1+distance){
						if ((w.getMove().getTargetTile().getRow()==curRow)||(w.getMove().getTargetTile().getRow()==curRow-1)){
							return true;
						}
					}
				}
			}
		} 
		else if(this.side.equals("left")){
			for(Wall w: wWall){
				if (w.getMove().getWallDirection().toString().compareTo("Vertical")==0){
					if (w.getMove().getTargetTile().getColumn()==curCol-distance){
						if ((w.getMove().getTargetTile().getRow()==curRow)||(w.getMove().getTargetTile().getRow()==curRow-1)){
							return true;
						}
					}
				}
			}
			for(Wall w: bWall){
				if (w.getMove().getWallDirection().toString().compareTo("Vertical")==0){
					if (w.getMove().getTargetTile().getColumn()==curCol-distance){
						if ((w.getMove().getTargetTile().getRow()==curRow)||(w.getMove().getTargetTile().getRow()==curRow-1)){
							return true;
						}
					}
				}
			}
		} 
		else if(this.side.equals("down")){
			for(Wall w: wWall){
				if (w.getMove().getWallDirection().toString().compareTo("Horizontal")==0){
					if (w.getMove().getTargetTile().getRow()==curRow+1-distance){
						if ((w.getMove().getTargetTile().getColumn()==curCol)||(w.getMove().getTargetTile().getColumn()==curCol-1)){
							return true;
						}
					}
				}
			}
			for(Wall w: bWall){
				if (w.getMove().getWallDirection().toString().compareTo("Horizontal")==0){
					if (w.getMove().getTargetTile().getRow()==curRow+1-distance){
						if ((w.getMove().getTargetTile().getColumn()==curCol)||(w.getMove().getTargetTile().getColumn()==curCol-1)){
							return true;
						}
					}
				}
			}
		}
		
		return false;
    }
    
    String isOpponentAdjacent(int curR, int curC, int oR, int oC){
    	if ((curR==oR)&&(curC==oC+1)){
    		return "left";
    	}
    	else if ((curR==oR)&&(curC==oC-1)){
    		return "right";
    	}
    	
    	else if ((curC==oC)&&(curR==oR+1)){
    		return "up";
    	}
    	else if ( (curC==oC)&&(curR==oR-1)){
    		return "down";
    	}
    	else {
    		return "no";
    	}
    }
    
    Boolean isBorderBlocking(int opRow, int opCol, String opSide){
    	if ((opSide.compareTo("up")==0)&&(opRow==1)){
    		return true;
    	}
    	
    	else if ((opSide.compareTo("down")==0)&&(opRow==9)){
    		return true;
    	}
    	
    	else if ((opSide.compareTo("left")==0)&&(opCol==0)){
    		return true;
    	}
    	
    	else if ((opSide.compareTo("right")==0)&&(opCol==9)){
    		return true;
    	}
    	else {
    		return false;
    	}
    }
	
    // Action to be called when an illegal move is attempted
    void illegalMove() { 
		status="illegal";
    }
    
    void legalMove() { 
		status="success";
		isValid=true;
    }
    
    
    // Enumeration for the possible moving directions
    // (directions are from the viewpoint of white player)
    enum MoveDirection { East, South, West, North; }
}
